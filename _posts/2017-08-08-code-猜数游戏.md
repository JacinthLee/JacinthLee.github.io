---
title: 猜数游戏
description: 
categories:
 - 编程题
tags:
---


牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是"Y"或者"N",表示牛牛选择的数是否是i的倍数。
例如,如果提示是"YYNYY",它表示这个数使1,2,4,5的倍数,但不是3的倍数。
注意到一些提示会出现错误。例如: 提示"NYYY"是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是"N"。此外,例如"YNNY"的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。
现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。
例如 n = 5:
合法的提示有:
YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY
YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY
所以输出12 
输入描述:
>输入包括一个整数n(1 ≤ n ≤ 10^6),表示已给提示的长度。

输出描述:
>输出一个整数,表示合法的提示个数。因为答案可能会很大,所以输出对于1000000007的模

示例1
输入
>5
输出
>12

错误解题思路：
所有提示个数为2的n次幂，去除不合法的提示数。

正确解题思路：
链接：https://www.nowcoder.com/questionTerminal/0a5b316cfe9d4c4ba89c6c57a1ee516e来源：牛客网

设dp[i]表示输入长度为i时的合法的提示个数，那么根据i的分类可能存在下面几种情况：
- i为素数，由于素数和前面的所有数都没有依赖关系，即第i位可以为Y或者N，所以dp[i]=dp[i-1]*2；
- i不是素数的幂次，也就是像6这样的数字，你会发现，它已经被第2位和第3位唯一确定了。例如23分别是YY，那么6一定是Y；23分别是YN或NY或NN，6一定是N，所以说这时候有dp[i]=dp[i-1]
- i是素数的幂次，它不能唯一确定。例如4，当2为Y时，4不确定，可以是Y，也可以是N。将4和2放入集合，若2取，4必定取，所以有NN，YN，YY三种情况。那么引申一下，加入8就是3个元素的集合，共4种情况，9就是2个元素的集合（3、9），有3种情况，以此类推。最后将这些情况相乘即可，因为这些集合之间相互不影响

因此，从上面分析中可以看出，长度为n的各位可以分为两类：
- 位数为素数或素数的幂次：这些位上的可能性取决于素数的幂次且小于n的那些数。
- 位数不是素数且不是素数的幂次：当素数位的字符确定了，这些位上的字符也都确定，即都只有一种可能性；

举个例子，当n=16，存在素数2，3，5，7，11，13。
素数2，2的幂次数有2，4，8，16。从后往前看，依次看16，8，4，2的字符取值。如果16取值为Y，那么2，4，8都只能为Y;如果16为N，则此时需要看8，如果8取值为Y，那么2，4都只能为Y；如果8为N，那么此时需要看4，如果4为Y，则此时2为Y；如果4为N，那么此时需要看2，2存在两种情况，结束。总的可能性为5种，为2的幂次数的个数+1。
素数3，3的幂次数有3，9。同样的，先看9，如果9取值为Y，则3为Y；如果9取值为N，那么此时看3，3存在两种可能性，结束。总的可能性为3，为3的幂次数的个数+1。
素数5，7，11，13，他们的幂次数都各只有一个，都为2，是各自素数的幂次数的个数+1。

所以，合法提示组合数问题转化为求所有小于等于n的素数及他们的幂次数的组合数的乘积。也就是把每一个素数和它的幂次归为一类，求出每一类的合法提示组合数，由于类与类之间没有重叠关系，因此总的组合数为所有类的组合数的乘积。
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int len=scanner.nextInt();
        long ans=1;
        boolean[] visited = new boolean[len+1];
        for(int i=2; i<=len; i++) {
            //找素数
            if(visited[i])
                continue;
            //处理素数的幂次
            for(int j=2*i; j<=len; j+=i)
                visited[j] = true;
            int count=0;
            long k=i;  //int会溢出
            while(k<=len) {
                k*=i;
                count++;
            }
            ans=ans*(count+1)%1000000007;
        }
        System.out.println(ans);
    }
}
```